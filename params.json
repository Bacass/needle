{"name":"Needle","tagline":"Multithreading library for Android.","body":"# Introduction\r\n\r\nNeedle makes multithreading simple on Android. \r\n\r\nAre you struggling with `Thread`, `Handler`, `Looper`, `AsyncTask`, `ThreadPoolExecutor`, `FutureTask`, `View.post()` or `Activity.runOnUiThread()`?\r\n\r\n```java\r\nNeedle.onMainThread().execute(new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        // e.g. change one of the views\r\n    }\r\n});\r\n```\r\n\r\nYou might be better off using `Needle`. \r\n\r\nNeedle supports Android 1.5 (API Level 3) and above; and it behaves the same on all platform versions.\r\n\r\n# Features\r\n\r\n## Do work on the UI/main thread  \r\n\r\n```java\r\nNeedle.onMainThread().execute(new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        // e.g. change one of the views\r\n    }\r\n});\r\n```\r\n\r\n## Do work on a background thread  \r\n\r\n```java\r\nNeedle.onBackgroundThread().execute(new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        // something cpu-intensive and/or not UI-related\r\n    }\r\n});\r\n```\r\n\r\nThe executor returned by `onBackgroundThread()` has a thread pool with 3 (`Needle.DEFAULT_POOL_SIZE`) threads. If all threads in the pool are busy executing code then `Runnable` instances are enqueued and executed as soon as possible.\r\n\r\nThis way you can make sure you never bog down the CPU with a lot of concurrent threads; number of concurrent threads is bounded.\r\n\r\n## Do work on a background thread with custom thread pool size\r\n\r\n```java\r\nNeedle.onBackgroundThread().withThreadPoolSize(6).execute(new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        // something that blocks often thus can have a larger thread pool,\r\n        // for instance, downloading a file (with blocking IO)\r\n    }\r\n});\r\n```\r\n\r\nSubsequent executors obtained with `Needle.onBackgroundThread().withThreadPoolSize(poolSize)` with the same `poolSize` parameter will use the same thread pool.\r\n\r\n`Needle.onBackgroundThread()` is equivalent to `Needle.onBackgroundThread().withThreadPoolSize(Needle.DEFAULT_POOL_SIZE)`.\r\n\r\n## Do work on a background thread serially\r\n\r\n```java\r\nNeedle.onBackgroundThread().serially().execute(new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        // something that we want to do serially but not on the main thread\r\n    }\r\n});\r\n```\r\n\r\n`Needle.onBackgroundThread().serially()` is equivalent to `Needle.onBackgroundThread().withThreadPoolSize(1)`.\r\n\r\n## Set different levels of concurrency for different task types\r\n\r\n```java\r\nNeedle\r\n\t.onBackgroundThread()\r\n\t.withTaskType(\"file-downloading\")\r\n\t.execute(new Runnable() {\r\n\t    @Override\r\n\t    public void run() {\r\n\t        // downloading a file in a thread pool \r\n\t        // different from thread pool of \"image-processing\"\r\n\t    }\r\n});\r\n\r\nNeedle\r\n\t.onBackgroundThread()\r\n\t.withTaskType(\"image-processing\")\r\n\t.execute(new Runnable() {\r\n\t    @Override\r\n\t    public void run() {\r\n\t        // processing an image in a thread pool \r\n\t        // different from thread pool of \"file-downloading\"\r\n\t    }\r\n});\r\n```\r\n\r\n```java\r\nNeedle\r\n\t.onBackgroundThread()\r\n\t.withTaskType(\"cpu-inensive-but-has-to-be-serial\")\r\n\t.withThreadPoolSize(1)\r\n\t.execute(new Runnable() {\r\n\t    @Override\r\n\t    public void run() {\r\n\t        // something that we want to do serially but not on the main thread\r\n\t    }\r\n});\r\n\r\nNeedle\r\n\t.onBackgroundThread()\r\n\t.withTaskType(\"something-else-that-has-to-be-serial\")\r\n\t.serially()\r\n\t.execute(new Runnable() {\r\n\t    @Override\r\n\t    public void run() {\r\n\t        // something else that we want to do serially \r\n\t        // and also not on the main thread\r\n\t        // and should not interfere with \r\n\t        // \"cpu-inensive-but-has-to-be-serial\" tasks\r\n\t    }\r\n});\r\n```\r\n\r\nTasks with different types will be executed independently from each other, i.e. each task type will have its own, separated thread pool.\r\n\r\nTo be more precise, in case of these two calls `Needle.onBackgroundThread().withThreadPoolSize(poolSizeA).withTaskType(taskTypeA).execute(runnableA)` and `Needle.onBackgroundThread().withThreadPoolSize(poolSizeB).withTaskType(taskTypeB).execute(runnableB)` the tasks `runnableA` and `runnableB` will be executed in the same thread pool if, and only if, `poolSizeA` equals `poolSizeB` and `taskTypeA` equals `taskTypeB`.\r\n\r\n`Needle.onBackgroundThread().withTaskType(taskType)` is equivalent to `Needle.onBackgroundThread().withTaskType(taskType).withThreadPoolSize(Needle.DEFAULT_POOL_SIZE)`.\r\n\r\n`Needle.onBackgroundThread().withThreadPoolSize(poolSize)` is equivalent to `Needle.onBackgroundThread().withTaskType(Needle.DEFAULT_TASK_TYPE).withThreadPoolSize(poolSize)`.\r\n\r\n## Calculate something on a background thread and then use the result on the UI/main thread \r\n\r\n```java\r\nNeedle.onBackgroundThread().execute(new UiRelatedTask<Integer>() {\r\n    @Override\r\n    protected Integer doWork() {\r\n        int result = 1+2;\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    protected void thenDoUiRelatedWork(Integer result) {\r\n        mSomeTextView.setText(\"result: \" + result);\r\n    }\r\n});\r\n```\r\n\r\nCallback `thenDoUiRelatedWork(Result result)` is executed on the UI/main thread.\r\n\r\n## Calculate something and publish progress updates on a background thread and then use the result on the UI/main thread\r\n\r\n```java\r\nNeedle.onBackgroundThread().execute(new UiRelatedProgressTask<String, Integer>() {\r\n    @Override\r\n    protected String doWork() {\r\n        int result = 0;\r\n        for (int i = 0; i < 10; i++) {\r\n            result += 1;\r\n            publishProgress(result);\r\n        }\r\n        return \"The result is: \" + result;\r\n    }\r\n\r\n    @Override\r\n    protected void thenDoUiRelatedWork(String result) {\r\n        mSomeTextView.setText(result);\r\n    }\r\n\r\n    @Override\r\n    protected void onProgressUpdate(Integer progress) {\r\n        mSomeTextView.setText(\"progress: \" + progress);\r\n    }\r\n});\t\t\t\t\r\n```\r\nBoth `thenDoUiRelatedWork(Result result)` and `onProgressUpdate(Progress progress)` are executed on the UI/main thread.\r\n\r\n## Cancel tasks\r\n\r\n```java\r\nCancelableTask task = new CancelableTask() {\r\n    @Override\r\n    protected void doWork() {\r\n        // will be never executed\r\n    }\r\n};\r\ntask.cancel();\r\nNeedle.onBackgroundThread().execute(task);\r\n```\t\r\n\r\nPassing a task to `.execute()` that is not canceled doesn't necessarily mean that it will be executed. If the task gets canceled while it is waiting it the thread pool queue (because all threads are busy to process it) then it won't be executed either (ever).  \r\n\r\n\r\n```java\r\nCancelableTask task = new CancelableTask() {\r\n    @Override\r\n    protected void doWork() {\r\n        int lotOfIterations = ...;\r\n        for (int i=0; i < lotOfIterations; i++) {\r\n        \tif (isCanceled()) {\r\n        \t\tbreak;\r\n        \t} else {\r\n        \t\t// work on current iteration\r\n        \t}\r\n        }\r\n    }\r\n};\r\n\r\nNeedle.onBackgroundThread().execute(task);\r\n// a little time goes by\r\ntask.cancel();\r\n```\t\r\n\r\nIn case your task takes a very long time to execute you may want to check inside `doWork()` whether the task has been canceled - to stop execution.\r\n\r\nClasses `CancelableTask`, `UiRelatedTask` and `UiRelatedProgressTask` are all cancelable.\r\n\r\n# Download\r\n\r\n<p><a href=\"http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.zsoltsafrany&a=needle&v=LATEST\">&darr; <span class=\"version-tag\">Latest</span> JAR</a></p>\r\n\r\nThe source code of Needle is [available on GitHub](https://github.com/ZsoltSafrany/needle).\r\n\r\n## Maven\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>com.zsoltsafrany</groupId>\r\n  <artifactId>needle</artifactId>\r\n  <version>1.0.0</version>\r\n</dependency>\r\n```\r\n\r\n## Gradle\r\n\r\n```Groovy\r\ncompile 'com.zsoltsafrany:needle:1.0.0'\r\n```\r\n\r\n# License\r\n```\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2014 Zsolt Safrany\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n```","google":"UA-53950173-1","note":"Don't delete this file! It's used internally to help with page regeneration."}